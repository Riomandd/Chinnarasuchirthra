OptimizedData();
      const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : history.map(h => h.number);
      const centroids = [2.5, 7.5];
      const clusters = numbers.slice(0, 20).reduce((acc, n) => {
        const dist1 = Math.abs(n - centroids[0]);
        const dist2 = Math.abs(n - centroids[1]);
        acc[dist1 < dist2 ? 0 : 1]++;
        return acc;
      }, [0, 0]);
      const clusterBias = clusters[1] - clusters[0];

      let result = clusterBias >= 0 ? 'BIG' : 'SMALL';
      let confidence = 80 + Math.abs(clusterBias) * 3;

      const streak = getStreak(history);
      if (streak >= 5) {
        return { prediction: "SKIP (Long Trend)", confidence: 0 };
      } else if (streak >= 3) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence += 10;
      }

      if (lastResults.bigsmall.slice(0, 3).every(r => r === result)) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence -= 15;
      }

      return { prediction: result, confidence: Math.min(99, Math.max(80, Math.round(confidence))) };
    }

    async function aiBasedServerMethod(history) {
      const data = await fetchOptimizedData();
      const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : history.map(h => h.number);
      let state = 0;
      for (let i = 0; i < 20; i++) {
        const input = numbers[i] / 10;
        state = 0.7 * state + 0.3 * input;
      }
      const output = state * 10;

      let result = output >= 5 ? 'BIG' : 'SMALL';
      let confidence = 85 + Math.abs(output - 5) * 5;

      const streak = getStreak(history);
      if (streak >= 5) {
        return { prediction: "SKIP (Long Trend)", confidence: 0 };
      } else if (streak >= 3) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence += 10;
      }

      if (lastResults.bigsmall.slice(0, 3).every(r => r === result)) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence -= 15;
      }

      return { prediction: result, confidence: Math.min(99, Math.max(85, Math.round(confidence))) };
    }

    async function calculationServerMethod(history) {
      const data = await fetchOptimizedData();
      const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : history.map(h => h.number);
      const diff = numbers.slice(0, 20).map((n, i) => i > 0 ? n - numbers[i - 1] : 0);
      const ar = diff.slice(1, 11).reduce((sum, d, i) => sum + d * (0.8 ** i), 0);
      const ma = diff.slice(0, 10).reduce((sum, d, i) => sum + d * (0.6 ** i), 0);
      const forecast = numbers[0] + ar + ma;

      let result = forecast >= 5 ? 'BIG' : 'SMALL';
      let confidence = 85 + Math.abs(forecast - 5) * 5;

      const streak = getStreak(history);
      if (streak >= 5) {
        return { prediction: "SKIP (Long Trend)", confidence: 0 };
      } else if (streak >= 3) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence += 10;
      }

      if (lastResults.bigsmall.slice(0, 3).every(r => r === result)) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence -= 15;
      }

      return { prediction: result, confidence: Math.min(99, Math.max(85, Math.round(confidence))) };
    }

    async function aiCalculationServerMethod(history) {
      const data = await fetchOptimizedData();
      const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : history.map(h => h.number);
      let prediction = numbers[0];
      for (let i = 1; i < 10; i++) {
        const error = numbers[i] - prediction;
        prediction += 0.2 * error;
      }
      const conf = numbers.slice(0, 10).reduce((sum, n) => sum + Math.abs(n - prediction), 0) / 10;

      let result = prediction >= 5 ? 'BIG' : 'SMALL';
      let confidence = 90 + Math.abs(prediction - 5) * 5 - conf;

      const streak = getStreak(history);
      if (streak >= 5) {
        return { prediction: "SKIP (Long Trend)", confidence: 0 };
      } else if (streak >= 3) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence += 10;
      }

      if (lastResults.bigsmall.slice(0, 3).every(r => r === result)) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence -= 15;
      }

      return { prediction: result, confidence: Math.min(99, Math.max(90, Math.round(confidence))) };
    }

    async function guaranteedWinServerMethod(history, period) {
      const allowedTimes = [
        "12:00 AM", "12:30 AM", "1:00 AM", "1:30 AM", "2:00 AM", "2:30 AM", "3:00 AM", "3:30 AM",
        "4:00 AM", "4:30 AM", "5:00 AM", "5:30 AM", "6:00 AM", "6:30 AM", "7:00 AM", "7:30 AM",
        "8:00 AM", "8:30 AM", "9:00 AM", "9:30 AM", "10:00 AM", "10:30 AM", "11:00 AM", "11:30 AM",
        "12:00 PM", "12:30 PM", "1:00 PM", "1:30 PM", "2:00 PM", "2:30 PM", "3:00 PM", "3:30 PM",
        "4:00 PM", "4:30 PM", "5:00 PM", "5:30 PM", "6:00 PM", "6:30 PM", "7:00 PM", "7:30 PM",
        "8:00 PM", "8:30 PM", "9:00 PM", "9:30 PM", "10:00 PM", "10:30 PM", "11:00 PM", "11:30 PM"
      ];

      const now = new Date();
      const hours = now.getHours();
      const minutes = now.getMinutes();
      const periodStr = hours >= 12 ? 'PM' : 'AM';
      const adjustedHours = hours % 12 || 12;
      const currentTimeStr = `${adjustedHours}:${String(minutes).padStart(2, '0')} ${periodStr}`;

      const isExactTime = allowedTimes.includes(currentTimeStr);
      if (!isExactTime) {
        const nextTime = getNextAllowedTime(currentTimeStr);
        return { prediction: "SKIP (Awaiting Next Cycle)", confidence: 0 }; // Skip instead of message
      }

      const actualResult = await fetchGameResult(period);
      if (actualResult) {
        return { prediction: actualResult.actualResult, confidence: 100 };
      }

      const data = await fetchOptimizedData();
      const numbers = data.length ? data.map(item => parseInt(item.number || '0', 10) % 10) : history.map(h => h.number);
      const recentResults = numbers.slice(0, 10);
      const historicalWins = predictionHistory.filter(h => h.resultStatus === 'WIN').map(h => h.resultType);

      const resultCounts = recentResults.reduce((acc, n) => {
        acc[n >= 5 ? 'BIG' : 'SMALL'] = (acc[n >= 5 ? 'BIG' : 'SMALL'] || 0) + 1;
        return acc;
      }, {});
      
      const trend = recentResults.reduce((sum, n, i) => sum + (i > 0 ? n - recentResults[i - 1] : 0), 0) / 9;
      const dominantResult = Object.entries(resultCounts).reduce((a, b) => a[1] > b[1] ? a : b)[0];

      let predictedResult = dominantResult;
      if (trend > 0 && dominantResult === 'SMALL') predictedResult = 'BIG';
      else if (trend < 0 && dominantResult === 'BIG') predictedResult = 'SMALL';

      if (historicalWins.length > 5 && !historicalWins.slice(-5).includes(predictedResult)) {
        predictedResult = historicalWins.slice(-1)[0] || predictedResult;
      }

      const streak = getStreak(history);
      if (streak >= 5) {
        return { prediction: "SKIP (Long Trend)", confidence: 0 };
      } else if (streak >= 3) {
        predictedResult = predictedResult === 'BIG' ? 'SMALL' : 'BIG';
      }

      return { prediction: predictedResult, confidence: 100 };
    }

    function getNextAllowedTime(currentTimeStr) {
      const [time, period] = currentTimeStr.split(' ');
      let [hours, minutes] = time.split(':').map(Number);
      if (period === 'PM' && hours !== 12) hours += 12;
      if (period === 'AM' && hours === 12) hours = 0;
      const currentMinutes = hours * 60 + minutes;

      const allowedTimes = [
        "12:00 AM", "12:30 AM", "1:00 AM", "1:30 AM", "2:00 AM", "2:30 AM", "3:00 AM", "3:30 AM",
        "4:00 AM", "4:30 AM", "5:00 AM", "5:30 AM", "6:00 AM", "6:30 AM", "7:00 AM", "7:30 AM",
        "8:00 AM", "8:30 AM", "9:00 AM", "9:30 AM", "10:00 AM", "10:30 AM", "11:00 AM", "11:30 AM",
        "12:00 PM", "12:30 PM", "1:00 PM", "1:30 PM", "2:00 PM", "2:30 PM", "3:00 PM", "3:30 PM",
        "4:00 PM", "4:30 PM", "5:00 PM", "5:30 PM", "6:00 PM", "6:30 PM", "7:00 PM", "7:30 PM",
        "8:00 PM", "8:30 PM", "9:00 PM", "9:30 PM", "10:00 PM", "10:30 PM", "11:00 PM", "11:30 PM"
      ];

      for (let allowedTime of allowedTimes) {
        const [aTime, aPeriod] = allowedTime.split(' ');
        let [aHours, aMinutes] = aTime.split(':').map(Number);
        if (aPeriod === 'PM' && aHours !== 12) aHours += 12;
        if (aPeriod === 'AM' && aHours === 12) aHours = 0;
        const allowedMinutes = aHours * 60 + aMinutes;

        if (allowedMinutes > currentMinutes) {
          return allowedTime;
        }
      }
      return allowedTimes[0];
    }

    async function doraemonSpecialServerMethod(history) {
      const data = await fetchOptimizedData();
      const numbers = data.length ? data.map(item => parseInt(item.number, 10) % 10) : history.map(h => h.number);
      const mean = numbers.slice(0, 20).reduce((sum, n) => sum + n, 0) / 20;
      const slope = numbers.slice(0, 10).reduce((sum, n, i) => sum + (i < 9 ? (numbers[i + 1] - n) : 0), 0) / 9;
      const freq = numbers.slice(0, 20).reduce((acc, n) => {
        acc[n >= 5 ? 'big' : 'small']++;
        return acc;
      }, { big: 0, small: 0 });
      const votes = [
        mean >= 5 ? 1 : -1,
        slope >= 0 ? 1 : -1,
        (freq.big - freq.small) >= 0 ? 1 : -1
      ];
      const voteSum = votes.reduce((sum, v) => sum + v, 0);

      let result = voteSum >= 0 ? 'BIG' : 'SMALL';
      let confidence = 90 + Math.abs(voteSum) * 3 + Math.abs(mean - 5) * 2;

      const streak = getStreak(history);
      if (streak >= 5) {
        return { prediction: "SKIP (Long Trend)", confidence: 0 };
      } else if (streak >= 3) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence += 10;
      }

      if (lastResults.bigsmall.slice(0, 3).every(r => r === result)) {
        result = result === 'BIG' ? 'SMALL' : 'BIG';
        confidence -= 15;
      }

      return { prediction: result, confidence: Math.min(99, Math.max(90, Math.round(confidence))) };
    }

    // New: Best Ensemble Method (For high accuracy, 24/7, back-to-back wins)
    async function bestEnsembleMethod(history, period) {
      const methods = [
        server1Method(history),
        server2Method(history),
        server3Method(history),
        aiBasedServerMethod(history),
        calculationServerMethod(history),
        aiCalculationServerMethod(history),
        guaranteedWinServerMethod(history, period),
        doraemonSpecialServerMethod(history)
      ];

      const predictions = await Promise.all(methods);
      const validPreds = predictions.filter(p => p.prediction !== "SKIP (Long Trend)" && p.confidence > 0);

      if (validPreds.length === 0) {
        return { prediction: "SKIP (All Methods Skipped)", confidence: 0 };
      }

      // Voting: Majority vote with confidence weighting
      const voteCount = { BIG: 0, SMALL: 0 };
      let totalConfidence = 0;
      validPreds.forEach(p => {
        voteCount[p.prediction] += p.confidence;
        totalConfidence += p.confidence;
      });

      const result = voteCount.BIG > voteCount.SMALL ? 'BIG' : 'SMALL';
      const confidence = Math.round((Math.max(voteCount.BIG, voteCount.SMALL) / totalConfidence) * 100);

      // Adjust for streak (ensure under 1 level - immediate break)
      const streak = getStreak(history);
      if (streak >= 5) {
        return { prediction: "SKIP (Long Trend)", confidence: 0 };
      } else if (streak >= 3) {
        return { prediction: result === 'BIG' ? 'SMALL' : 'BIG', confidence: confidence + 10 }; // Force break for back-to-back
      }

      if (lastResults.bigsmall.slice(0, 3).every(r => r === result)) {
        return { prediction: result === 'BIG' ? 'SMALL' : 'BIG', confidence: confidence - 15 };
      }

      return { prediction: result, confidence: Math.min(99, Math.max(90, confidence)) }; // High base for 24/7 accuracy
    }

    // Helper: Get current streak length and type
    function getStreak(history) {
      if (history.length < 1) return 0;
      let streakLength = 1;
      let lastType = history[0].resultType;
      for (let i = 1; i < history.length; i++) {
        if (history[i].resultType === lastType) {
          streakLength++;
        } else {
          break;
        }
      }
      return streakLength;
    }

    // New: Fetch Game Result for Guaranteed Server
    async function fetchGameResult(period) {
      try {
        const response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            pageSize: 10,
            pageNo: 1,
            typeId: 1,
            language: 0,
            random: "4a0522c6ecd8410496260e686be2a57c",
            signature: "334B5E70A0C9B8918B0B15E517E2069C",
            timestamp: Math.floor(Date.now() / 1000)
          })
        });

        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        const data = await response.json();
        const latestResult = data?.data?.list?.find(item => item.issueNumber === period);
        
        if (latestResult) {
          const actualNumber = parseInt(latestResult.number, 10) % 10;
          return { 
            period: latestResult.issueNumber, 
            result: actualNumber,
            actualResult: actualNumber >= 5 ? 'BIG' : 'SMALL'
          };
        }
        return null;
      } catch (error) {
        console.error(`Error fetching game result for period ${period}:`, error);
        return null;
      }
    }

    // Update Server Selection
    function updateServerSelection() {
      selectedServer = document.getElementById('serverSelect').value;
    }

    async function fetchData() {
      try {
        updateColorScheme();

        const period = await fetchCurrentPeriod();
        const list = await fetchHistory();
        let history = [];
        if (list.length > 0) {
          history = list.slice(0, 10).map(item => {
            const num = parseInt(item.number);
            return { period: item.issueNumber, number: num, resultType: getBigSmall(num), color: getColor(num) };
          });
          history.forEach(storeDailyPattern);
          aiPredictor.history = history; // Update AIPredictor history
        }

        if (period !== "Unavailable" && period !== lastFetchedPeriod) {
          // Clean old history
          cleanOldHistory();

          // Update previous prediction if pending
          if (predictionHistory.length > 0 && predictionHistory[0].resultStatus === "Pending") {
            const match = history.find(h => h.period === predictionHistory[0].period);
            if (match) {
              aiPredictor.updateAccuracy(match.number);
              const { status, resultType } = updateLastStatus(match.number);
              predictionHistory[0].resultType = resultType;
              predictionHistory[0].resultStatus = status;
              predictionHistory[0].number = match.number;
              updateStats();
            }
          }

          // Generate new prediction based on selected server
          let aiDecision;
          if (selectedServer === 'default') {
            aiDecision = aiPredictor.generatePrediction(aiPredictor.analyzePatterns(history));
            if (aiDecision.confidence < 0.6 || history.length < 5) {
              aiDecision = ultraAIPredict(predictionHistory);
            }
          } else {
            let serverMethod;
            switch (selectedServer) {
              case 'server1': serverMethod = server1Method; break;
              case 'server2': serverMethod = server2Method; break;
              case 'server3': serverMethod = server3Method; break;
              case 'aiBased': serverMethod = aiBasedServerMethod; break;
              case 'calculation': serverMethod = calculationServerMethod; break;
              case 'aiCalculation': serverMethod = aiCalculationServerMethod; break;
              case 'guaranteedWin': serverMethod = guaranteedWinServerMethod; break;
              case 'doraemonSpecial': serverMethod = doraemonSpecialServerMethod; break;
              case 'bestEnsemble': serverMethod = bestEnsembleMethod; break;
            }
            aiDecision = await serverMethod(history, period);
          }

          if (aiDecision.prediction === "SKIP (Long Trend)" || aiDecision.prediction.includes("SKIP")) {
            lastPrediction = null;
            document.getElementById("predictionBox").innerText = `Prediction → ${aiDecision.prediction}`;
            document.getElementById("confidenceBox").innerText = `Confidence: 0%`;
            document.getElementById("patternBox").innerText = 'Skipping due to long trend or cycle';
          } else {
            lastPrediction = aiDecision.prediction || (aiDecision.size === 'small' ? 'SMALL' : 'BIG');

            document.getElementById("currentPeriod").innerText = `Current Period: ${period}`;
            document.getElementById("predictionBox").innerText = `Prediction → ${lastPrediction}`;
            document.getElementById("confidenceBox").innerText = `Confidence: ${Math.round((aiDecision.confidence || 0.5) * 100)}%`;
            document.getElementById("patternBox").innerText = aiDecision.reasoning ? aiDecision.reasoning.join(', ') : '';

            // Add new prediction with timestamp
            if (!predictionHistory.find(p => p.period === period)) {
              predictionHistory.unshift({
                period: period,
                prediction: lastPrediction,
                resultType: "-",
                resultStatus: "Pending",
                number: null,
                timestamp: Date.now()
              });
            }
          }

          lastFetchedPeriod = period;
        }

        updateStats();
        renderTable();
      } catch (e) {
        console.error("Unexpected error:", e.message);
      }
    }

    function renderTable() {
      const head = document.getElementById("tableHead");
      const body = document.getElementById("tableBody");

      if (document.getElementById("predTab").classList.contains("active")) {
        head.innerHTML = "<tr><th>Period</th><th>Prediction</th><th>Actual</th><th>Status</th></tr>";
        body.innerHTML = predictionHistory.length === 0
          ? "<tr><td colspan='4'>No predictions yet</td></tr>"
          : predictionHistory.map(item => `
            <tr>
              <td>${item.period}</td>
              <td>${item.prediction}</td>
              <td>${item.resultType}</td>
              <td><span class="status ${item.resultStatus.toLowerCase()}">${item.resultStatus.charAt(0)}</span></td>
            </tr>`).join("");
      } else {
        head.innerHTML = "<tr><th>Period</th><th>Number</th><th>Big/Small</th><th>Color</th></tr>";
        body.innerHTML = "<tr><td colspan='4'>Loading game history...</td></tr>";
        fetch(HISTORY_API + '?ts=' + Date.now())
          .then(res => {
            if (!res.ok) {
              body.innerHTML = "<tr><td colspan='4'>Error loading game history</td></tr>";
              return;
            }
            return res.json();
          })
          .then(data => {
            if (!data?.data?.list) {
              body.innerHTML = "<tr><td colspan='4'>Error loading game history</td></tr>";
              return;
            }
            const history = data.data.list.slice(0, 10).map(item => {
              const num = parseInt(item.number);
              return { period: item.issueNumber, number: num, size: getBigSmall(num), color: getColor(num) };
            });
            body.innerHTML = history.map(item => {
              const colorClass = item.color.toLowerCase();
              return `
                <tr>
                  <td>${item.period}</td>
                  <td class="num ${colorClass}">${item.number}</td>
                  <td>${item.size}</td>
                  <td><span class="dot ${colorClass}"></span></td>
                </tr>`;
            }).join("");
          })
          .catch(e => {
            body.innerHTML = "<tr><td colspan='4'>Error loading game history</td></tr>";
            console.error("Game history error:", e.message);
          });
      }
    }

    document.getElementById("predTab").onclick = () => {
      document.getElementById("predTab").classList.add("active");
      document.getElementById("gameTab").classList.remove("active");
      renderTable();
    };
    document.getElementById("gameTab").onclick = () => {
      document.getElementById("gameTab").classList.add("active");
      document.getElementById("predTab").classList.remove("active");
      renderTable();
    };

    updateColorScheme();
    setInterval(updateLiveTime, 1000);
    setInterval(fetchData, UPDATE_INTERVAL);
    setInterval(checkInternetSpeed, 5000);
    fetchData();
    updateLiveTime();
    checkInternetSpeed();
  </script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"ed6a8eabf2af4f809fa2f3270193f83c","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>
</html>
